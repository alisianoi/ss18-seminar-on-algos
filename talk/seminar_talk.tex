\documentclass[presentation,professionalfonts]{beamer}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{IEEEtrantools}
\usepackage{bm}
\usepackage{hyperref}
\tolerance=1000
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz}
\usepackage{xspace}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{appendixnumberbeamer}

\usepackage[
backend=biber,
style=numeric,
sortlocale=en_US,
url=false,
doi=true,
eprint=false,
giveninits=false,
maxbibnames=20,
maxnames=20,
maxcitenames=4
]{biblatex}
\addbibresource{templ.bib}

\usepackage{lmodern}
\usefonttheme[onlymath]{serif}

\setbeamercovered{highly dynamic}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{bibliography item}[text]
\usetheme{TUW}

\newcommand{\semname}{Scheduling Algorithms for Clusters, Distributed Systems, and Multi-core Nodes}
\newcommand{\semester}{SS 2018}

\institute[TU Wien]{Seminar ``\semname''\\\semester}
\titlegraphic{\includegraphics[height=.7cm]{./logos/par-logo.pdf}\quad\includegraphics[height=.7cm]{./logos/info-logo.pdf}}

% change this, of course
\date{\today}
\title[Scheduling Jobs with Max-Min Fairness]{Scheduling Jobs across Geo-Distributed Datacenters with Max-Min Fairness}
\author[Aleksandr Lisianoi]{Aleksandr Lisianoi}

\begin{document}

\maketitle

\begin{frame}{Seminar Talk's Main Sources}
  \begin{enumerate}
  \item \fullcite{Chen2017}
  \item \fullcite{Meyer1976}
  \end{enumerate}
\end{frame}

\begin{frame}{Outline}
  % \tableofcontents[currentsection]
  \tableofcontents
\end{frame}

\section{Introduction}

\begin{frame}{Problem Description}
  \begin{block}{The Main Question}
    Given a \emph{large volume} of data stored in \emph{geographically distributed} datacenters, how to effectively run \emph{multiple} analytical jobs in a \emph{fair} fashion?
    \end{block}

  Things to consider:

  \begin{enumerate}
    \item Data locality
    \item Network bandwidth
  \end{enumerate}
\end{frame}

\begin{frame}{What is an Analytic Job?}

  A data analytic job usually consists of several consecutive stages, each of which consists of several parallel tasks.

  Examples:
  \begin{itemize}
  \item 2007 The New York Times https://open.blogs.nytimes.com/2007/11/01/self-service-prorated-super-computing-fun/
  \item 2017 Spotify https://labs.spotify.com/2017/10/16/big-data-processing-at-spotify-the-road-to-scio-part-1/
    Alternating Least Squares: if User x Score matrix is binary, then the author could parallelize efficiently with Spark
    Spotify operates a Hadoop cluster to over 2500 nodes and over 100 PBs of capacity running about 20,000 independent jobs per day.
    \end{itemize}

\end{frame}

\begin{frame}{Background Definitions}
  \begin{IEEEeqnarray*}{llCl}
    \text{Datacenter: }                                     & \mathcal{D}   &=& \left\{1, 2, \dots, J\right\} \\
    \text{Datacenter capacity for \(j\in\mathcal{D}\): }    & \mathcal{A}   &=& \left\{a_1, a_2, \dots, a_J\right\} \\
    \text{Data parallel job: }                              & \mathcal{K}   &=& \left\{1, 2, \dots, K\right\} \\
    \text{Parallel tasks for job \(k \in \mathcal{K}\): }   & \mathcal{T}_k &=& \left\{1, 2, \dots, n_k\right\} \\
  \end{IEEEeqnarray*}
  For each task \(i\in\mathcal{T}_k\) of job \(k\): network transfer time \(c^k_{i, j}\) and execution time \(e^k_{i, j}\) if datacenter \(j\) is used. Source datacenters for task \(i\) of job \(k\) are \(S^k_i\).

  \begin{equation*}
    c^k_{i, j} = \left\{ \,
    \begin{IEEEeqnarraybox}[][c]{l?s}
      \IEEEstrut
      0, &  when \(S^k_i = \left\{j\right\}\)\\
      \max_{s\in S^k_i, s\neq j}\left(\frac{d^{k, s}_i}{b_{s,j}}\right) & otherwise
      \IEEEstrut
    \end{IEEEeqnarraybox}
    \right.
  \end{equation*}
\end{frame}

\newcommand{\foralltdk}{\forall i \in \mathcal{T}_k, \forall j\in\mathcal{D}, \forall k\in\mathcal{K}}
\newcommand{\fcapacity}{\sum_{k\in\mathcal{K}}\sum_{i\in\mathcal{T}_k} x^k_{i, j} \leq a_j}
\newcommand{\fcapacityq}{\forall j\in\mathcal{D}}
\newcommand{\fpresence}{\sum_{j\in\mathcal{D}}x^k_{i, j} = 1}
\newcommand{\fpresenceq}{\forall i\in\mathcal{T}_k, \forall k\in\mathcal{K}}

\begin{frame}{First Optimization Problem}
  \begin{IEEEeqnarray}{lrCll}
    \text{lexmin}_{\bm{x}} & \bm{f} &=&\left(\tau_1, \tau_2, \dots, \tau_K\right) &\\
    \text{s.t.} & \tau_k &=& \max_{i\in\mathcal{T}_k, j\in\mathcal{D}} x^k_{i, j}\left(c^k_{i, j} + e^k_{i, j}\right), &\forall k\in\mathcal{K} \label{eq:goal}\\
    &&& \fcapacity,  &\fcapacityq\label{eq:capacity}\\
    &&& \fpresence,  &\fpresenceq\label{eq:presence}\\
    &&& x^k_{i, j} \in \left\{0, 1\right\}. &\foralltdk\label{eq:onehot}
  \end{IEEEeqnarray}

  Constraint \eqref{eq:goal}: a task requires as long as its longest job. \\
  Constraint \eqref{eq:capacity}: capacity of the datacenter is not exceeded. \\
  Constraint \eqref{eq:presence}: each job is assigned to exactly one datacenter. \\
\end{frame}

\begin{frame}{Transformation Plan}
  \begin{itemize}
  \item Separable convex objective
  \item Totally unimodular linear constraints
  \item Apply \(\lambda\)-representation technique
  \end{itemize}
\end{frame}

\begin{frame}{Towards Single Objective and Linear Constraints}
  From multiple-objective to single-objective optimization:
  \begin{IEEEeqnarray}{ll}
    \min_{\bm{x}} & \quad \max_{k\in\mathcal{K}}\left(\tau_k\right) \\
    \text{s.t.}  & \quad \text{Constraints \eqref{eq:goal}, \eqref{eq:capacity}, \eqref{eq:presence} and \eqref{eq:onehot} hold}
  \end{IEEEeqnarray}

  \pause

  From non-linear constraints to linear constraints:

  \begin{IEEEeqnarray}{ll}
    \min_{\bm{x}} & \quad \max_{k\in\mathcal{K}}\left(\max_{i\in\mathcal{T}_k, j\in\mathcal{D}} x^k_{i, j}\left(c^k_{i, j} + e^k_{i, j}\right)\right) \\
    \text{s.t.}  & \quad \text{Constraints \eqref{eq:capacity}, \eqref{eq:presence} and \eqref{eq:onehot} hold}
  \end{IEEEeqnarray}

  \pause

  \begin{equation*}
        \phi (x^k_{i, j}) =_{df} x^k_{i, j} (c^k_{i, j} + e^k_{i, j}), \forall i\in\mathcal{T}_k, j\in \mathcal{D}, k\in\mathcal{K}
  \end{equation*}

  \pause

  From minimizing the triple maximum to lexicographic minimization:
  \begin{IEEEeqnarray}{ll}
    \text{lexmin}_{\bm{x}} & \quad \bm{g} = \left(\phi(x^1_{1, 1}), \dots, \phi(x^k_{i, j}), \dots, \phi(x^K_{n_k, J})\right) \\
    \text{s.t.}           & \quad \text{Constraints \eqref{eq:capacity}, \eqref{eq:presence} and \eqref{eq:onehot} hold}
  \end{IEEEeqnarray}
\end{frame}

\begin{frame}{Towards a Separable Objective Function}
  \begin{IEEEeqnarray*}{lCl}
    g^m &=_{df}& \text{element of vector }\bm{g}\text{ at position }m \\
    M &=_{df} & |\bm{g}| = J\sum_{k = 1}^{K}n_k \\
    \varphi(\bm{g}) & =_{df} & \sum_{m = 1}^{M}M^{g_m}
  \end{IEEEeqnarray*}
  \begin{lemma}
    \(\varphi(.)\) preserves the order of ``lexicographically no greater'' \(\preceq\), i.e.
    \[\bm{g}(x^*) \preceq \bm{g}(x) \iff \varphi(\bm{g}(x^*)) \leq\varphi(\bm{g}(x))\]
  \end{lemma}
\end{frame}

\begin{frame}{Separable Objective Function Achieved}
  \begin{IEEEeqnarray}{ll}
    \min_{\bm{x}} & \quad \sum_{k\in\mathcal{K}}\sum_{i\in\mathcal{T}_k}\sum_{j\in\mathcal{D}} M^{\varphi(x^k_{i, j})} \\
    \text{s.t.}  & \quad \text{Constraints \eqref{eq:capacity}, \eqref{eq:presence} and \eqref{eq:onehot} hold}
  \end{IEEEeqnarray}
\end{frame}

\newcommand{\flambdas}{\lambda^{k, 0}_{i, j} + \lambda^{k, 1}_{i, j}}
\newcommand{\fsmember}{\flambdas M^{\left(c^k_{i, j} + e^k_{i, j}\right)}}
\newcommand{\rplus}{\mathbf{R}^{+}}

\begin{frame}{Removing Integrality Constraints}
  Lambda representation technique:
  \begin{IEEEeqnarray}{lCl}
    M^{\varphi\left(x^k_{i, j}\right)} &=& \sum_{s\in\{0,1\}} M^{s\left(c^k_{i, j} + e^k_{i, j}\right)}\lambda^{k, s}_{i, j} = \fsmember \\
    x^k_{i, j} &=& \sum_{s\in\{0, 1\}}s\lambda^{k, s}_{i, j} = \lambda^{k, 1}_{i, j} \\
    \sum_{s\in\{0, 1\}} \lambda^{k, s}_{i, j} &=& \flambdas = 1 \\
    \lambda^{k, s}_{i, j} &\in& \rplus
    \end{IEEEeqnarray}
\end{frame}

\begin{frame}{Final Problem}
  \begin{IEEEeqnarray}{Cl}
    \min_{\bm{x}} & \quad \sum_{k\in\mathcal{K}}\sum_{i\in\mathcal{T}_k}\sum_{j\in\mathcal{D}} \left(\fsmember\right) \\
    \text{s.t.}  & \quad x^k_{i, j} = \lambda^{k, 1}_{i, j}, \foralltdk \\
                 & \quad \flambdas = 1, \foralltdk \\
                 & \quad x^k_{i, j}, \lambda^{k, 0}_{i, j}, \lambda^{k, 1}_{i, j} \in \rplus, \foralltdk \\
    & \quad \fcapacity, \fcapacityq \\
    & \quad \fpresence, \fpresenceq
  \end{IEEEeqnarray}  
\end{frame}

\begin{frame}{Unimodular Matrix}
  \begin{definition}[Unimodular Matrix]
    Matrix \(M\) is a \emph{unimodular matrix} if it is a \emph{square}, \emph{integer} matrix with \[\det M = \pm 1\]
  \end{definition}
  \begin{definition}[Unimodular Matrix]
    Matrix \(M\) is a \emph{unimodular matrix} if it is an
    \emph{integer}, \emph{invertible} matrix and its inverse is also
    an \emph{integer}, \emph{invertible} matrix.
  \end{definition}
  Examples: identity matrix, \emph{permutation matrix}, pascal matrix, \dots
\end{frame}

\begin{frame}{Totally Unimodular Matrix}
  \begin{definition}{Totally Unimodular Matrix}
    Matrix \(M\) is a \emph{totally unimodular matrix} if its every
    non-singular square submatrix is unimodular.
  \end{definition}

  \begin{definition}{Totally Unimodular Matrix}
    Matrix \(M\) is a \emph{totally unimodular matrix} if its every
    \emph{square submatrix} \(A\) has \(\det A\in \{-1, 0, 1\}\)
  \end{definition}

  \begin{definition}{Totally Unimodular Matrix}
    Matrix \(A\) is a \emph{totally unimodular matrix} if its every
    element \(A_{i, j}\in \{-1, 0, 1\}\) and any row subset \(R\) can
    be divided into two disjoint subsets \(R_1\) and \(R_2\) s.t.
    \[\left|\sum_{i\in R_1} a_{i, j} - \sum_{i\in R_2}a_{i, j}\right| \leq 1, \forall j\in{1, 2, \dots, n}\]
    \end{definition}
\end{frame}

\begin{frame}{Totally Unimodular Matrices in Optimization}
  Important well-known optimization fact: if \(M\) is totally
  unimodular and \(b\) is integral, then linear programs \(\left\{\min
  cx | Mx \geq b, x\geq 0\right\}\) and \(\{\max cx | Mx \leq b\}\)
  have integral optima for any \(c\).
  \end{frame}

\section{Experimental Evaluation}

\begin{frame}
  \frametitle{Experimental Results}
  \begin{center}
  \includegraphics[width=.7\textwidth]{./graph1}\\
  image source: \textcite{Dang16}
  \end{center}
\end{frame}

\section{Conclusions}

\begin{frame}
  \frametitle{Conclusions}
  \begin{itemize}
  \item nice paper 
  \item substantial improvement
  \end{itemize}  
\end{frame}


\begin{frame}[fragile]{References}
\printbibliography
\end{frame}

\appendix

\begin{frame}{In Case You Expect Questions}
\centering
\begin{itemize}
\item foo
\item bar
\item barfoo
\end{itemize}
\end{frame}

\end{document}
